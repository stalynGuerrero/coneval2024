# 02_Union_predictores.R

Para la ejecución del presente archivo, debe abrir el archivo **02_Union_predictores.R** disponible en la ruta *Rcodes/2020/02_Union_predictores.R*.

Este script en R está orientado a la integración y limpieza de bases de datos a nivel municipal para el año 2020, combinando datos satelitales y de contexto. Primero, el entorno de trabajo se limpia y se cargan las bibliotecas necesarias para la manipulación y análisis de datos, incluyendo tidyverse, data.table, y openxlsx.

En la primera parte, se carga una base de datos satelital en formato RDS, se renombra una columna para alinear los nombres y se eliminan columnas no necesarias. Luego, se obtienen los códigos municipales únicos de esta base de datos. A continuación, se carga una base de datos adicional en formato Stata (.dta), se convierten algunas variables a factores y se escalan las variables numéricas. Se realiza un análisis para identificar códigos municipales presentes en la base de datos satelital pero no en la de contexto, y se comprueba si hay columnas sin valores faltantes en la base de datos de contexto. Finalmente, se realiza un inner_join para combinar ambas bases de datos utilizando solo las columnas sin valores faltantes y se guarda el resultado en un archivo RDS para futuros análisis.

```{r, eval=FALSE}
### Cleaning R environment ###
rm(list = ls())

#################
### Libraries ###
#################
library(tidyverse)
library(data.table)
library(openxlsx)
library(magrittr)
library(DataExplorer)
library(haven)
library(purrr)
library(labelled)
cat("\f")

################################################################################
# Lectura de bases de contexto 2020
################################################################################
## Covariables
# Contexto_munXX : la base de datos contexto_20XX.dta contiene información de 
# variables a nivel municipal. 

# Cargar la base de datos satelital y renombrar la columna "CVEGEO" a "cve_mun"
satelital <-
  readRDS("../input/2020/predictores/statelevel_predictors_satelite.rds") %>%
  rename(cve_mun  = CVEGEO) %>% mutate(ent = NULL)

# Obtener los códigos municipales únicos de la base de datos satelital
cod_mun <- satelital %>% distinct(cve_mun)

# Cargar la base de datos "Contexto_mun20" en formato Stata y renombrar la columna "CVEGEO" a "cve_mun"
Contexto_mun <- read_dta("../input/2020/predictores/contexto_2020.dta")
Contexto_mun %>% as_factor() %>% 
  apply(., 2, n_distinct) %>% sort()

Contexto_mun$elec_mun19
Contexto_mun$elec_mun20
Contexto_mun$smg1
Contexto_mun$ql_porc_cpa_urb
Contexto_mun$ql_porc_cpa_rur   
Contexto_mun$dec_geologicas 
Contexto_mun$dec_hidrometeo  

Contexto_mun %<>% as_factor() %>%
  mutate_at(
    .vars = c(
      "elec_mun19",
      "elec_mun20",
      "smg1",
      "ql_porc_cpa_urb",
      "ql_porc_cpa_rur",
      "dec_geologicas",
      "dec_hidrometeo"
    ),
    as.factor
  ) %>%
  mutate_if(is.numeric, function(x)
    as.numeric(scale(x)))

# Realizar una anti_join para identificar códigos municipales presentes en "cod_mun" pero no en "Contexto_mun"
anti_join(cod_mun, Contexto_mun)

# Realizar un análisis para determinar si alguna columna de "Contexto_mun" no tiene valores faltantes
paso <- apply(Contexto_mun, 2, function(x) !any(is.na(x)))

# Mostrar la frecuencia de columnas sin valores faltantes
table(paso)

# Realizar una inner_join entre las bases de datos "satelital" y "Contexto_mun" utilizando solo las columnas sin valores faltantes
statelevel_predictors <- inner_join(satelital, Contexto_mun[, paso])

# Obtener las dimensiones de la base de datos resultante
dim(statelevel_predictors)

## Guardar 
saveRDS(statelevel_predictors,file = "../input/2020/predictores/statelevel_predictors_df.rds")

```

