# 14_estimacion_municipios_ipm_pobreza.R

Para la ejecución del presente análisis, se debe abrir el archivo **14_estimacion_municipios_ipm_pobreza.R** disponible en la ruta *Rcodes/2020/14_estimacion_municipios_ipm_pobreza.R*.

Este script en R realiza un análisis exhaustivo para calibrar y validar indicadores de pobreza a nivel municipal, utilizando modelos predictivos y datos de encuestas. Primero, el entorno de trabajo se limpia y se cargan las librerías necesarias para la manipulación de datos (`tidyverse`, `data.table`, `magrittr`, etc.) y para realizar cálculos estadísticos (`lme4`, `survey`, `srvyr`). Luego, se leen datos de predicciones y encuestas ampliadas, junto con información adicional sobre las líneas de bienestar.

En la sección inicial de procesamiento, se unen y mutan los datos de la encuesta ENIGH para calcular indicadores de pobreza y vulnerabilidad multidimensional. Se asignan categorías de pobreza (`ipm`) y se crean nuevas variables que reflejan la pobreza moderada y extrema, basadas en umbrales de ingreso y carencias sociales.

El script luego se centra en la preparación de datos para la calibración de modelos. La muestra ampliada se ajusta para incluir variables adicionales y predicciones de ingreso y carencias sociales. A continuación, se inicia un bucle que itera sobre un conjunto de códigos de entidad territorial. Para cada entidad, se filtran y ajustan los datos de la encuesta ampliada y se simulan nuevas variables (como ingresos y carencias sociales) utilizando distribuciones probabilísticas basadas en las predicciones anteriores. 

Dentro de cada iteración, se realiza una calibración de los datos utilizando el método de "raking", que ajusta las estimaciones de los indicadores a las estimaciones poblacionales conocidas. Los resultados de la calibración se calculan para cada municipio y se comparan con los datos originales para validar la precisión de las estimaciones. Finalmente, los resultados de cada iteración se guardan en archivos RDS separados para su análisis posterior y se reporta el tiempo total de ejecución del proceso. 

Este enfoque permite realizar un ajuste fino de los modelos predictivos y asegurar que las estimaciones de pobreza sean lo más precisas posible, utilizando simulaciones y técnicas avanzadas de calibración.


```{r, eval=FALSE}
### Cleaning R environment ###
rm(list = ls())

#################
### Libraries ###
#################
library(tidyverse)
library(data.table)
library(openxlsx)
library(magrittr)
library(haven)
library(labelled)
library(sampling)
library(lme4)
library(survey)
library(srvyr)
source("../source/benchmarking_indicador.R")
################################################################################
# Lectura de datos 
################################################################################

predicciones <- readRDS( "../output/2020/modelos/predicciones.rds")
muestra_ampliada <- readRDS("../output/2020/encuesta_ampliada.rds")
encuesta_enigh <-readRDS("../input/2020/enigh/encuesta_sta.rds") %>%
  mutate(ingreso = ictpc)

LB <-
  read.delim(
    "../input/2020/Lineas_Bienestar.csv",
    header = TRUE,
    sep = ";",
    dec = ","
  ) %>% mutate(area = as.character(area))



################################################################################
# IPM en la enigh
################################################################################
encuesta_enigh <-
  encuesta_enigh %>% inner_join(LB)  %>% 
  mutate(
    tol_ic = ic_segsoc + ic_ali_nc + ic_asalud + ic_cv +  ic_sbv + ic_rezedu,
    ipm   = case_when(
      # Población en situación de pobreza.
      ingreso < lp  &  tol_ic >= 1 ~ "I",
      # Población vulnerable por carencias sociales.
      ingreso >= lp & tol_ic >= 1 ~ "II",
      # Poblacion vulnerable por ingresos.
      ingreso <= lp & tol_ic < 1 ~ "III",
      # Población no pobre multidimensional y no vulnerable.
      ingreso >= lp & tol_ic < 1 ~ "IV"
    ),
    # Población en situación de pobreza moderada.
    pobre_moderada = ifelse(c(ingreso > li & ingreso < lp) &
                              tol_ic > 2, 1, 0),
    pobre_extrema = ifelse(ipm == "I" & pobre_moderada == 0, 1, 0)
    
  )
################################################################################
# preparando  encuesta intercensal
################################################################################

muestra_ampliada <- muestra_ampliada %>% inner_join(LB) 
muestra_ampliada   %<>% mutate(
  ic_asalud = ifelse(ic_asalud == 1, 1,0),
  ic_cv = ifelse(ic_cv == 1, 1,0),
  ic_sbv = ifelse(ic_sbv == 1, 1,0),
  ic_rezedu = ifelse(ic_rezedu == 1, 1,0),
  tol_ic4 = ic_asalud + ic_cv +  ic_sbv + ic_rezedu,
  pred_segsoc = predicciones$pred_segsoc,
  pred_ingreso = predicciones$pred_ingreso,
  desv_estandar_residual = predicciones$desv_estandar_residual,
  pred_ic_ali_nc = predicciones$pred_ic_ali_nc
) 

# dir.create("../output/2020/iteraciones/mpio_calib")
# map(
#   paste0(
#     "../output/2020/iteraciones/mpio_calib/",
#     unique(encuesta_enigh$ent)
#   ),
#   ~ dir.create(path = .x)
# )

rm(predicciones)

ii_ent <- "02"
iter = 1

for(ii_ent in c("03", "06", "23", "04", "01", "22", "27", "25", "18",
                "05", "17", "28", "10", "26", "09", "32", "08", "19", "29", 
                "24", "11", "31", "13", "16", "12", "14", "15", "07", "21", 
                "30",  "20" ,"02"
)){
  
cat("####################################################################\n")
inicio <- Sys.time()
print(inicio)

muestra_post = muestra_ampliada %>% filter(ent == ii_ent)

total_mpio  <- muestra_post %>% group_by(cve_mun) %>% 
  summarise(den_mpio = sum(factor),.groups = "drop") %>% 
  mutate(tot_ent = sum(den_mpio))


encuesta_sta = encuesta_enigh %>% filter(ent == ii_ent)

encuesta_sta %<>% na.omit()

tot_pob <- encuesta_sta %>% 
  group_by(ipm) %>% 
  summarise(num_ent = sum(fep),.groups = "drop") %>% 
  transmute(ipm,   prop_ipm = num_ent/sum(num_ent),
            tx_ipm =  sum(total_mpio$den_mpio)*prop_ipm) %>% 
  filter(ipm != "I")

pobreza <-  encuesta_sta %>% summarise(
  pobre_ext = weighted.mean(pobre_extrema, fep),
  pob_mod = weighted.mean(pobre_moderada, fep),
  pobre_moderada = sum(total_mpio$den_mpio)*pob_mod,
  pobre_extrema = sum(total_mpio$den_mpio)*pobre_ext)

Tx_ipm <- setNames(tot_pob$tx_ipm,paste0("ipm_",tot_pob$ipm))
Tx_pob <- pobreza[,3:4] %>% as.vector() %>% unlist()

tx_mun <- setNames(total_mpio$den_mpio,
                   paste0("cve_mun_",total_mpio$cve_mun))

Tx_hat <- c(Tx_pob, Tx_ipm,   tx_mun)


for( iter in 1:200){
  cat("\n municipio = ", ii_ent,"\n\n")
  cat("\n iteracion = ", iter,"\n\n")
 


############################################
muestra_post %<>% 
  mutate(
    ic_segsoc = rbinom(n = n(), size = 1, prob = pred_segsoc),
    ic_ali_nc = rbinom(n = n(), size = 1, prob = pred_ic_ali_nc),
    ingreso = pred_ingreso + rnorm(n = n(),mean = 0,
                                   desv_estandar_residual),
    tol_ic = tol_ic4 + ic_segsoc + ic_ali_nc
  ) %>% mutate(
    ipm   = case_when(
      # Población en situación de pobreza.
      ingreso < lp  &  tol_ic >= 1 ~ "I",
      # Población vulnerable por carencias sociales.
      ingreso >= lp & tol_ic >= 1 ~ "II",
      # Poblacion vulnerable por ingresos.
      ingreso <= lp & tol_ic < 1 ~ "III",
      # Población no pobre multidimensional y no vulnerable.
      ingreso >= lp & tol_ic < 1 ~ "IV"
    ),
    # Población en situación de pobreza moderada.
    pobre_moderada = ifelse(c(ingreso > li & ingreso < lp) &
                              tol_ic > 2, 1, 0),
    pobre_extrema = ifelse(ipm == "I" & pobre_moderada == 0, 1, 0))  



Xk <- muestra_post %>% select("ipm", "cve_mun") %>% 
  fastDummies::dummy_columns(select_columns = c("ipm", "cve_mun")) %>% 
  select(names(Tx_hat[-c(1:2)]))

diseno_post <- bind_cols(muestra_post,Xk) %>% 
  mutate(fep = factor) %>%
  as_survey_design(
    ids = upm,
    weights = fep,
    nest = TRUE,
    # strata = estrato
  )

mod_calib <-  as.formula(paste0("~ -1+",paste0(names(Tx_hat), collapse = " + ")))

diseno_calib <- calibrate(diseno_post, formula = mod_calib, 
                          population = Tx_hat,calfun = "raking")

estima_calib_ipm  <- diseno_calib %>% group_by(cve_mun,ipm) %>% 
  summarise(est_ipm = survey_mean(vartype ="var"))

estima_calib_pob  <- diseno_calib %>% group_by(cve_mun) %>% 
  summarise(est_pob_ext = survey_mean(pobre_extrema , vartype ="var"),
            est_pob_mod = survey_mean(pobre_moderada  , vartype ="var" ))

estima_calib <- pivot_wider(
  data = estima_calib_ipm,
  id_cols = "cve_mun",
  names_from = "ipm",
  values_from = c("est_ipm", "est_ipm_var"),values_fill = 0
) %>% full_join(estima_calib_pob)


valida_ipm <- estima_calib_ipm %>% inner_join(total_mpio, by = "cve_mun") %>% 
  group_by(ipm) %>% 
  summarise(prop_ampliada = sum(est_ipm*den_mpio)/unique(tot_ent)) %>% 
  full_join(tot_pob, by = "ipm")

valida_pob <- estima_calib_pob %>% select(cve_mun, est_pob_ext , est_pob_mod) %>% 
  inner_join(total_mpio, by = "cve_mun") %>%
  summarise(pob_ext_ampliada = sum(est_pob_ext * den_mpio) / unique(tot_ent),
            pob_mod_ampliada = sum(est_pob_mod * den_mpio) / unique(tot_ent),
            ipm_I = pob_ext_ampliada + pob_mod_ampliada) %>% 
  bind_cols(pobreza[,1:2])



saveRDS(list(valida = list(valida_pob = valida_pob, 
                           valida_ipm = valida_ipm),
             estima_calib = estima_calib),
        file = paste0( "../output/2020/iteraciones/mpio_calib/",
                       ii_ent,"/iter",iter,".rds"))
gc()
}
  fin <- Sys.time()
  tiempo_total <- difftime(fin, inicio, units = "mins")
  print(tiempo_total)
  cat("####################################################################\n")
  
  }
```

