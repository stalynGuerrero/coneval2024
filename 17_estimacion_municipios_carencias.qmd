# 17_estimacion_municipios_carencias.R {-}

Para la ejecución del presente análisis, se debe abrir el archivo **17_estimacion_municipios_carencias.R** disponible en la ruta *Rcodes/2020/17_estimacion_municipios_carencias.R*.

El código proporcionado realiza una serie de procesos para la estimación y calibración de indicadores de carencias a nivel municipal en base a datos de encuestas. Comienza limpiando el entorno de trabajo y cargando las librerías necesarias, como `tidyverse`, `data.table`, y `survey`, además de leer los datos de predicciones y encuestas. Se preparan las bases de datos con variables calculadas para las carencias, incluyendo indicadores de carencias sociales y líneas de pobreza.

Posteriormente, el script filtra y prepara los datos de la encuesta para cada entidad (municipio) específica. Para cada municipio, se realiza un proceso iterativo de simulación donde se actualizan las variables del modelo (como ingreso y carencias sociales) con base en predicciones previas. Se calcula la población total y se ajusta la muestra para realizar estimaciones calibradas utilizando el método de "raking", que ajusta los pesos de la muestra para que coincidan con las estimaciones de la población.

Finalmente, se guarda cada iteración de los resultados calibrados en archivos RDS y se calcula el tiempo total de ejecución. Cada archivo contiene estimaciones para los indicadores de pobreza en cada municipio. El script utiliza técnicas de muestreo y calibración para asegurar que las estimaciones sean consistentes con las características de la población y se gestionan errores potenciales durante el proceso de calibración.


#### Configuración y carga de librerías{-}

```{r, eval=FALSE}
### Cleaning R environment ###
rm(list = ls())
library(tidyverse)
library(data.table)
library(openxlsx)
library(magrittr)
library(haven)
library(labelled)
library(sampling)
library(lme4)
library(survey)
library(srvyr)
source("../source/benchmarking_indicador.R")
```

#### Lectura de datos{-}

```{r, eval=FALSE}
################################################################################
# Lectura de datos 
################################################################################
predicciones <- readRDS("../output/2020/modelos/predicciones.rds")
encuesta_ampliada <- readRDS("../output/2020/encuesta_ampliada.rds")
encuesta_enigh <- readRDS("../input/2020/enigh/encuesta_sta.rds") %>%
  mutate(ingreso = ictpc)

LB <- read.delim(
  "../input/2020/Lineas_Bienestar.csv",
  header = TRUE,
  sep = ";",
  dec = ","
) %>% mutate(area = as.character(area))
```

#### IPM en la ENIGH  {-}

```{r, eval=FALSE}
################################################################################
# IPM en la enigh
################################################################################
encuesta_enigh <- encuesta_enigh %>%
  inner_join(LB) %>%
  mutate(
    tol_ic = ic_segsoc + ic_ali_nc + ic_asalud + ic_cv + ic_sbv + ic_rezedu,
    pobrea_lp = ifelse(ingreso < lp, 1, 0),
    pobrea_li = ifelse(ingreso < li, 1, 0),
    tol_ic_1 = ifelse(tol_ic > 0, 1, 0),
    tol_ic_2 = ifelse(tol_ic > 2, 1, 0)
  )
```

#### Preparación de encuesta intercensal {-}

```{r, eval=FALSE}
################################################################################
# preparando encuesta intercensal
################################################################################
encuesta_ampliada <- encuesta_ampliada %>%
  inner_join(LB) %>%
  mutate(
    ic_asalud = ifelse(ic_asalud == 1, 1, 0),
    ic_cv = ifelse(ic_cv == 1, 1, 0),
    ic_sbv = ifelse(ic_sbv == 1, 1, 0),
    ic_rezedu = ifelse(ic_rezedu == 1, 1, 0),
    tol_ic4 = ic_asalud + ic_cv + ic_sbv + ic_rezedu,
    pred_segsoc = predicciones$pred_segsoc,
    pred_ingreso = predicciones$pred_ingreso,
    desv_estandar_residual = predicciones$desv_estandar_residual,
    pred_ic_ali_nc = predicciones$pred_ic_ali_nc
  )

# dir.create("output/2020/iteraciones/mpio_calib_carencia")
# map(
#   paste0(
#     "output/2020/iteraciones/mpio_calib_carencia/",
#     unique(encuesta_enigh$ent)
#   ),
#   ~ dir.create(path = .x)
# )

rm(predicciones)

ii_ent <- "20"

list_yks <- list(
  c("pobrea_lp"),
  c("pobrea_li"),
  c("tol_ic_1", "tol_ic_2", "ic_segsoc", "ic_ali_nc")
)
```

#### Iteraciones y calibración {-}

```{r, eval=FALSE}
for(ii_ent in c("03", "06", "23", "04", "01", "22", "27", "25", "18",
                 "05", "17", "28", "10", "26", "09", "32", "08", "19", "29",
                 "24", "11", "31", "13", "16", "12", "14", "15", "07", "21",
                 "30", "20", "02")) {

  cat("####################################################################\n")
  inicio <- Sys.time()
  print(inicio)

  yks <- unlist(list_yks)
  muestra_post <- encuesta_ampliada %>% filter(ent == ii_ent)
  
  total_mpio <- muestra_post %>% group_by(cve_mun) %>%
    summarise(den_mpio = sum(factor), .groups = "drop") %>%
    mutate(tot_ent = sum(den_mpio))
  
  encuesta_sta <- encuesta_enigh %>% filter(ent == ii_ent) %>% na.omit()
  
  tot_pob <- encuesta_sta %>%
    summarise_at(.vars = yks, .funs = list(
      ~ weighted.mean(., w = fep, na.rm = TRUE) * sum(total_mpio$den_mpio)
    ))

  top_caren <- unlist(as.vector(tot_pob))
  tx_mun <- setNames(total_mpio$den_mpio, paste0("cve_mun_", total_mpio$cve_mun))
  Tx_hat <- c(top_caren, tx_mun)

  for(iter in 1:200) {
    cat("\n municipio = ", ii_ent, "\n\n")
    cat("\n iteracion = ", iter, "\n\n")
    
    ############################################
    muestra_post <- muestra_post %>%
      mutate(
        ic_segsoc = rbinom(n = n(), size = 1, prob = pred_segsoc),
        ic_ali_nc = rbinom(n = n(), size = 1, prob = pred_ic_ali_nc),
        ingreso = pred_ingreso + rnorm(n = n(), mean = 0, sd = desv_estandar_residual),
        tol_ic = tol_ic4 + ic_segsoc + ic_ali_nc
      ) %>%
      mutate(
        pobrea_lp = ifelse(ingreso < lp, 1, 0),
        pobrea_li = ifelse(ingreso < li, 1, 0),
        tol_ic_1 = ifelse(tol_ic > 0, 1, 0),
        tol_ic_2 = ifelse(tol_ic > 2, 1, 0)
      )

    estima_calib_ipm <- list()
    for(ii in 1:length(list_yks)) {
      yks <- list_yks[[ii]]
      
      var_calib <- c(yks, names(tx_mun))
      Xk <- muestra_post %>% select("cve_mun") %>%
        fastDummies::dummy_columns(select_columns = c("cve_mun"), remove_selected_columns = TRUE)
      
      diseno_post <- bind_cols(muestra_post, Xk) %>%
        mutate(fep = factor) %>%
        as_survey_design(
          ids = upm,
          weights = fep,
          nest = TRUE
        )
      
      mod_calib <- as.formula(paste0("~ -1 +", paste0(var_calib, collapse = " + ")))
      diseno_calib <- tryCatch({
        calibrate(diseno_post, formula = mod_calib, 
                  population = Tx_hat[var_calib], calfun = "raking",
                  maxit = 50)
      }, error = function(e) {
        message("Error en la calibración: ", yks)
        return(NULL)
      })
      
      if (is.null(diseno_calib)) {
        next
      }
      
      estima_calib_ipm[[ii]] <- diseno_calib %>% group_by(cve_mun) %>%
        summarise_at(.vars = yks, .funs = list(
          ~ survey_mean(., vartype = "var", na.rm = TRUE))
        )
    }
    
    estima_calib_ipm <- keep(estima_calib_ipm, ~ !is.null(.)) %>%
      reduce(inner_join)
    
    saveRDS(list(estima_calib = estima_calib_ipm),
            file = paste0("../output/2020/iteraciones/mpio_calib_carencia/",
                           ii_ent, "/iter", iter, ".rds"))
    gc()
  }
  
  fin <- Sys.time()
  tiempo_total <- difftime(fin, inicio, units = "mins")
  print(tiempo_total)
  cat("####################################################################\n")
}
```

